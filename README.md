# get_next_line (42)

Читает из файлового дескриптора по одной строке за вызов. Строка включает завершающий символ новой строки ('\n'), если он есть. Возвращает NULL при ошибке или при достижении EOF без данных.

Особенности реализации:
- Быстро обрабатывает очень длинные строки (giant_line*) без таймаутов в francinette --strict.
- Без утечек (включая последнюю строку без '\n').
- Соответствует ограничению: один файловый дескриптор (mandatory).

## Состав проекта

- get_next_line.h — прототипы и настройка BUFFER_SIZE.
- get_next_line.c — логика чтения/накопления/извлечения строки:
  - append_buf: амортизированно линейный рост буфера с удвоением емкости.
  - read_to_stash: чтение порциями до первой новой строки или EOF.
  - extract_line: выделение одной строки, корректное управление остатком.
- get_next_line_utils.c — служебные функции:
  - gnl_strlen, gnl_strchr(int c), gnl_strdup, gnl_substr,
  - gnl_strjoin (освобождает s1 только при УСПЕХЕ аллокации),
  - локальный memcpy для быстрых копирований.

## Интерфейс

char *get_next_line(int fd);

Контракты:
- Возвращает новую строку (heap), которую должен освобождать вызывающий (free).
- Если данных больше нет (EOF) или произошла ошибка — возвращает NULL.
- BUFFER_SIZE можно задать при компиляции (-D BUFFER_SIZE=...).

## Как это работает (кратко)

- Между вызовами хранится накопленный буфер stash (static).
- read_to_stash читает из fd кусками BUFFER_SIZE и добавляет в stash, пока в очередном прочитанном блоке не встретится '\n' или не наступит EOF.
- extract_line возвращает одну строку из начала stash (до '\n' включительно, либо все остатки, если '\n' нет).
- Если после извлечения строки остатка нет — stash = NULL (без аллокации пустых строк).

Почему быстро:
- append_buf увеличивает емкость stash экспоненциально (64, 128, 256, …), поэтому суммарная сложность по числу скопированных байт — амортизированно O(n), нет квадратичной деградации на длинных строках.

## Сложность и память

- Время: O(M) на одну возвращенную строку, где M — общее число реально прочитанных байт до этой строки.
- Память: хранится только «хвост» (остаток после выданной строки). Емкость увеличивается логарифмически по числу расширений.

## Граничные случаи

- Пустой файл: сразу возвращает NULL.
- Файл без '\n': возвращает одну строку (без '\n'), затем NULL.
- Файл с единственным '\n': возвращает "\n", затем NULL.
- Ошибка read/alloc: очищает состояние и возвращает NULL.
- Последняя строка: если остатка нет — stash = NULL (утечек нет).

## Сборка (macOS)

Пример локальной сборки:
- С дефолтным BUFFER_SIZE=100:
  clang -Wall -Wextra -Werror get_next_line.c get_next_line_utils.c -o gnl
- С переопределением BUFFER_SIZE:
  clang -Wall -Wextra -Werror -D BUFFER_SIZE=1024 get_next_line.c get_next_line_utils.c -o gnl

## Пример использования

Пример простого main.c (для локальной проверки):

```c
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include "get_next_line.h"

int main(void) {
    int fd = open("file.txt", O_RDONLY);
    if (fd < 0) return 1;
    char *line;
    while ((line = get_next_line(fd)) != NULL) {
        printf("%s", line);
        free(line);
    }
    close(fd);
    return 0;
}
```

Сборка:
- clang -Wall -Wextra -Werror -D BUFFER_SIZE=100 get_next_line.c get_next_line_utils.c main.c -o demo

## Тестирование

- Франсинетта:
  - francinette --strict
- Собственные тесты:
  - проверьте giant_line.txt и giant_line_nl.txt (очень длинные строки),
  - проверьте файлы: пустой, только '\n', без '\n', mix.

## Частые вопросы на защите

- Почему один fd? Это ограничение части mandatory. Для bonus нужно хранить отдельный stash на каждый fd (обычно через список/таблицу).
- Почему удвоение емкости? Это уменьшает число копирований и даёт амортизированно линейное время на рост строки.
- Почему не realloc? Можно и realloc, но явное malloc+копирование полностью прозрачно и остаётся в рамках разрешённых функций.
- Кто освобождает память? Каждая возвращенная строка — ответственность вызывающего (free). Внутренние буферы освобождаются при отсутствии остатка или при ошибке.
- Почему gnl_strchr принимает int c? Такова сигнатура в стандартной библиотеке; это важно для корректного сравнения с '\0' и любых байт.
- Как избегаются утечки на последней строке? Если остатка нет — stash = NULL (не выделяем пустую строку).
- Из-за чего были таймауты раньше? Из-за «склейки» строк на каждом чтении через strjoin (копирование уже накопленного содержимого каждый раз) — O(n^2) при очень длинной строке. Исправлено за счёт буфера с удвоением емкости.

## Изменения по сравнению с наивной версией

- Ускорено накопление данных: вместо posixимвольного конкатенирования — append с удвоением емкости.
- Исправлена утечка: не храним пустой остаток после последней строки.
- gnl_strjoin освобождает s1 только при УСПЕХЕ аллокации (чтобы не было double free при ошибке malloc).
- gnl_strchr принимает int c (совместимо с libc).
- Локальный memcpy для быстрых копирований без <string.h>.

## Ограничения

- Не потокобезопасно.
- Один дескриптор (mandatory).
- Используются только разрешённые функции: read, malloc, free и собственные утилиты.

---
Если нужно добавить раздел про bonus (много fd) или mini-bench/валгринд-заметки —