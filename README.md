# get_next_line

## Описание задания

Функция `get_next_line` должна считывать данные из файла или стандартного ввода построчно. Она возвращает строку, заканчивающуюся символом новой строки (`\n`), если он есть, или строку до конца файла (EOF). После достижения конца файла функция возвращает `NULL`.

---

## Как работает `get_next_line`

1. **Параметр `fd`**:
   - `fd` — это файловый дескриптор, который указывает на открытый файл или поток ввода.
   - Например:
     - `0` — стандартный ввод (stdin).
     - `1` — стандартный вывод (stdout).
     - `2` — стандартный поток ошибок (stderr).
     - Если файл открыт с помощью `open`, `fd` будет идентификатором этого файла.

2. **Чтение данных**:
   - Данные читаются блоками с помощью функции `read`. Размер блока задается макросом `BUFFER_SIZE`.
   - Вместо чтения по символу, данные читаются блоками для повышения производительности.

3. **Использование связного списка**:
   - Вместо массива используется связный список для хранения данных.
   - Каждый узел списка содержит часть строки, считанную из файла.
   - Если строка занимает несколько блоков, данные объединяются из нескольких узлов.

4. **Обработка символа новой строки (`\n`)**:
   - Если в текущем буфере найден символ `\n`, функция создает строку до этого символа и возвращает её.
   - Остаток данных после `\n` сохраняется в списке для следующего вызова.

5. **Завершение работы**:
   - Если достигнут конец файла (`read` возвращает `0`), функция возвращает оставшиеся данные.
   - Если произошла ошибка (`read` возвращает `-1`), функция возвращает `NULL`.

6. **Очистка памяти**:
   - После возврата строки использованные узлы списка очищаются.
   - Если список пуст, память полностью освобождается.

---

## Пример поведения

Файл `example.txt` содержит: Hello, world! 42 is awesome. End of file.


- Первый вызов `get_next_line(fd)` вернет: `"Hello, world!\n"`
- Второй вызов вернет: `"42 is awesome.\n"`
- Третий вызов вернет: `"End of file."`
- Четвертый вызов вернет: `NULL` (конец файла).

---

## Алгоритм работы

1. Проверить валидность `fd` и `BUFFER_SIZE`.
2. Использовать `read` для чтения данных из файла в буфер.
3. Добавить данные из буфера в связный список.
4. Проверить наличие символа `\n`:
   - Если найден, создать строку до `\n` и сохранить остаток.
   - Если не найден, продолжить чтение.
5. Вернуть строку, если она готова, или `NULL`, если достигнут конец файла.
6. Очистить память, связанную с узлами списка.

---

## Особенности реализации

- **Гибкость**: Использование связного списка позволяет динамически обрабатывать строки любого размера.
- **Эффективность**: Чтение блоками уменьшает количество системных вызовов.
- **Безопасность**: Память освобождается после использования, чтобы избежать утечек.

---

## Примечания

- Убедитесь, что `BUFFER_SIZE` определен и имеет положительное значение.
- Тестируйте функцию с разными сценариями:
  - Пустые файлы.
  - Файлы без символов новой строки.
  - Большие файлы.
  - Несколько файлов одновременно.


### Буфер (`BUFFER_SIZE = 8`):
- Первый вызов `read` считывает: `"Hello, w"`
- Второй вызов `read` считывает: `"orld!\n42"`
- Третий вызов `read` считывает: `" is awes"`
- Четвертый вызов `read` считывает: `"ome.\nEnd"`

### Узлы связного списка:
1. Узел 1: `"Hello, w"`
2. Узел 2: `"orld!\n"`
3. Узел 3: `"42 is awes"`
4. Узел 4: `"ome.\n"`
5. Узел 5: `"End of file."`

### Возврат строк:
1. Первый вызов `get_next_line` объединяет узлы 1 и 2 и возвращает: `"Hello, world!\n"`.
2. Второй вызов объединяет узлы 3 и 4 и возвращает: `"42 is awesome.\n"`.
3. Третий вызов возвращает узел 5: `"End of file."`.
4. Четвертый вызов возвращает `NULL` (конец файла).

---

## Советы по реализации

- Используйте статическую переменную для хранения указателя на начало связного списка.
- Реализуйте вспомогательные функции для работы со списком:
  - Создание нового узла.
  - Добавление узла в конец списка.
  - Очистка списка.
- Убедитесь, что память освобождается корректно после каждого вызова `get_next_line`.
- Тестируйте функцию с разными значениями `BUFFER_SIZE` и разными типами файлов:
  - Пустые файлы.
  - Файлы с длинными строками.
  - Файлы без символов новой строки.
  - Несколько файлов, обрабатываемых одновременно.